{
  "meta": {
    "language": "go",
    "language_version": "1.16",
    "language_name": "Go",
    "structure": "lists"
  },
  "concepts": {
    "name_of_ordered_mutable_list": {
      "comment": "It is similar to an array just dynamically sized",
      "code": "Slice"
    },
    "create_a_ordered_mutable_list": {
      "comment": "s is the list(slice) and int is the data type it can hold",
      "code": "var s = [] int{1, 2, 3}"
    },
    "ordered_mutable_list_start_number": {
      "code": "0"
    },
    "ordered_mutable_list_can_be_appended": {
      "code": "Yes"
    },
    "ordered_mutable_list_can_be_inserted_in_middle": {
      "code": "Yes"
    },
    "access_element_in_ordered_mutable_list": {
      "code": "list[index]"
    },
    "insert_into_beginning_of_ordered_mutable_list": {
      "comment": "Create a new slice and append the previous one to it",
      "code": "s = append([]int{element}, s...)"
    },
    "insert_into_end_of_ordered_mutable_list": {
      "code": "s = append(s, element)"
    },
    "insert_into_middle_of_ordered_mutable_list": {
      "code": "s = append(x[:index+1], x[index:]...)\ns[index]=value"
    },
    "erase_element_at_beginning_of_ordered_mutable_list": {
      "code": "s = s[1:]"
    },
    "erase_element_at_end_of_ordered_mutable_list": {
      "code": "s = s[:len(s)-1]"
    },
    "erase_element_in_middle_of_ordered_mutable_list": {
      "code": "s = append(s[:index], s[index+1:]...)"
    },
    "swap_elements_in_ordered_mutable_list": {
      "code": "s[index1], s[index2] = s[index2], s[index1]"
    },
    "delete_ordered_mutable_list": {
      "code": "s = nil"
    },
    "name_of_unordered_mutable_list": {
      "not-implemented": true
    },
    "create_a_unordered_mutable_list": {
      "not-implemented": true
    },
    "unordered_mutable_list_start_number": {
      "not-implemented": true
    },
    "unordered_mutable_list_can_be_appended": {
      "not-implemented": true
    },
    "unordered_mutable_list_can_be_inserted_in_middle": {
      "not-implemented": true
    },
    "access_element_in_unordered_mutable_list": {
      "not-implemented": true
    },
    "insert_into_beginning_of_unordered_mutable_list": {
      "not-implemented": true
    },
    "insert_into_end_of_unordered_mutable_list": {
      "not-implemented": true
    },
    "insert_into_middle_of_unordered_mutable_list": {
      "not-implemented": true
    },
    "erase_element_at_beginning_of_unordered_mutable_list": {
      "not-implemented": true
    },
    "erase_element_at_end_of_unordered_mutable_list": {
      "not-implemented": true
    },
    "erase_element_in_middle_of_unordered_mutable_list": {
      "not-implemented": true
    },
    "swap_elements_in_unordered_mutable_list": {
      "not-implemented": true
    },
    "delete_unordered_mutable_list": {
      "not-implemented": true
    },
    "name_of_ordered_immutable_list": {
      "not-implemented": true
    },
    "create_a_ordered_immutable_list": {
      "not-implemented": true
    },
    "ordered_immutable_list_start_number": {
      "not-implemented": true
    },
    "access_element_in_ordered_immutable_list": {
      "not-implemented": true
    },
    "delete_ordered_immutable_list": {
      "not-implemented": true
    },
    "name_of_unordered_immutable_list": {
      "not-implemented": true
    },
    "create_a_unordered_immutable_list": {
      "not-implemented": true
    },
    "unordered_immutable_list_start_number": {
      "not-implemented": true
    },
    "access_element_in_unordered_immutable_list": {
      "not-implemented": true
    },
    "delete_unordered_immutable_list": {
      "not-implemented": true
    },
    "name_of_mutable_hashed_list": {
      "code": "map"
    },
    "create_a_mutable_hashed_list": {
      "code": "var my_map = map[key_type] value_type {\n   key1: value1\n   key2: value2\n} "
    },
    "insert_element_to_mutable_hashed_list": {
      "code": "my_map[key] = value"
    },
    "erase_element_from_mutable_hashed_list": {
      "code": "delete(my_map, key)"
    },
    "delete_mutable_hashed_list": {
      "code": "my_map = nil"
    },
    "name_of_immutable_hashed_list": {
      "not-implemented": true
    },
    "create_a_immutable_hashed_list": {
      "not-implemented": true
    },
    "insert_element_to_immutable_hashed_list": {
      "not-implemented": true
    },
    "erase_element_from_immutable_hashed_list": {
      "not-implemented": true
    },
    "delete_immutable_hashed_list": {
      "not-implemented": true
    },
    "create_a_mutable_set": {
      "not-implemented": true
    },
    "get_key_from_mutable_set": {
      "not-implemented": true
    },
    "get_value_from_mutable_set": {
      "not-implemented": true
    },
    "get_all_keys_from_mutable_set": {
      "not-implemented": true
    },
    "get_all_values_from_mutable_set": {
      "not-implemented": true
    },
    "swap_key_and_value_in_mutable_set": {
      "not-implemented": true
    },
    "delete_mutable_set": {
      "not-implemented": true
    },
    "create_a_immutable_set": {
      "not-implemented": true
    },
    "get_key_from_immutable_set": {
      "not-implemented": true
    },
    "get_value_from_immutable_set": {
      "not-implemented": true
    },
    "get_all_keys_from_immutable_set": {
      "not-implemented": true
    },
    "get_all_values_from_immutable_set": {
      "not-implemented": true
    },
    "swap_key_and_value_in_immutable_set": {
      "not-implemented": true
    },
    "delete_immutable_set": {
      "not-implemented": true
    },
    "find_element_at_position": {
      "not-implemented": true
    },
    "find_element_by_value": {
      "comment": "Here s is the slice (list) and value is the search query",
      "code": "for _, v := range s {\n    if s == value {\n        return true\n    }\n}\nreturn false"
    },
    "find_minimum_element": {
      "comment": "Here s is the slice(list) and min is the minimum value",
      "code": "min = s[0]\nfor _, value := range s {\n    if (value < min) {\n        min = value\n    }\n}"
    },
    "find_maximum_element": {
      "comment": "Here s is the slice(list) and max is the maximum value",
      "code": "max = s[0]\nfor _, value := range s {\n    if (value > max) {\n        max = value\n    }\n}"
    },
    "convert_list_to_string": {
      "comment": "Built-in \"strings\" package needs to be imported first",
      "code": "str := strings.Join(slice, \" \")"
    },
    "concatenate_two_lists": {
      "code": "final_list := append(list1, list2...)"
    },
    "split_list_at_index": {
      "code": "s1 := s[0:index+1] \ns2 := s[index+1:]"
    },
    "split_list_at_value": {
      "not-implemented": true
    },
    "duplicate_a_list": {
      "code": "new_list = list"
    },
    "duplicate_subset_of_list": {
      "code": "new_list = list[start:end]"
    },
    "get_list_length": {
      "code": "len(list)"
    },
    "resize_list": {
      "not-implemented": true
    },
    "do_two_lists_match_exactly": {
      "comment": "Need to import standard library \"reflect\"",
      "code": "reflect.DeepEqual(list1, list2)"
    },
    "do_two_lists_contain_same_items": {
      "comment": "Need to import standard library \"reflect\"",
      "code": "reflect.DeepEqual(list1, list2)"
    },
    "does_list_satisfy_some_expression": {
      "not-implemented": true
    },
    "does_list_not_satisfy_an_expression": {
      "not-implemented": true
    },
    "sort_list": {
      "comment": "Need to import standard library \"sort\"; can also use Floats64s or Strings",
      "code": "sort.Ints(list)"
    },
    "shuffle_list": {
      "not-implemented": true
    },
    "reverse_list": {
      "not-implemented": true
    },
    "map": {
      "not-implemented": true
    },
    "filter": {
      "not-implemented": true
    },
    "reduce_left": {
      "not-implemented": true
    },
    "reduce_right": {
      "not-implemented": true
    }
  }
}
